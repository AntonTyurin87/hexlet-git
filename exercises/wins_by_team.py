data = [("A", "B"), ("B", "C"), ("A", "C")]

def wins_by_team(data):

    b = {k: v for k, v in data}

    for i in data:
    
        if i[0] in b and i[1] not in b.get(i[0]):
            b.update({i[0]: {b.get(i[0]), i[1]}})
            print(b)

        if i[0] in b and i[1] == b.get(i[0]):
            b.update({i[0]: {i[1]}})

    
    return b

print(wins_by_team(data))


'''
Предположим, что нам нужно анализировать результаты матчей "команда против команды" по некоторому виду спорта.
Для простоты будем считать, что "ничья" в этом виде спорта не предусмотрена и каждый матч описывается парой 
(кортежем) строк, где первая именует победителя, а вторая проигравшего. 
И сами с собой команды пусть тоже не играют :)

Вам предстоит реализовать функцию wins_by_team(), которая должна принимать перечень (iterable) матчей 
в качестве единственного аргумента и возвращать словарь, ключами которого выступали бы имена команд, 
а значениями множества названий команд которых данная команда-ключ обыграла хотя бы раз.

from solution import wins_by_team
wins_by_team([])
# {}
wins_by_team([("A", "B")])
# {'A': {'B'}}
wins_by_team([("A", "B"), ("B", "A")])
# {'A': {'B'}, 'B': {'A'}}
wins_by_team(
    [("A", "B"), ("B", "C"), ("A", "C")]
) == {'A': {'B', 'C'}, 'B': {'C'}}
# True

Это задание можно выполнить в процедурном стиле с помощью defaultdict или dict.setdefault и изменяемых множеств, 
однако попробуйте описать декларативное решение с использованием comprehensions!
'''